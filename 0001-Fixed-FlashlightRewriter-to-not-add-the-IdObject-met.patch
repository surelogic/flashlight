From 1055b4342050300dbfb83ae443a243defa24b376 Mon Sep 17 00:00:00 2001
From: Aaron Greenhouse <aarong@surelogic.com>
Date: Thu, 17 Nov 2011 14:19:35 -0500
Subject: [PATCH] Fixed FlashlightRewriter to not add the IdObject methods to
 the class if any ancestor is instrumented.

Previously, it only checked the super class. But you can have situations
where the superclass is not instrumented, by a more distanct ancestor
is.
---
 .../rewriter/FlashlightClassRewriter.java          |   22 +++++++++++++++++++-
 1 files changed, 21 insertions(+), 1 deletions(-)

diff --git a/flashlight-instrumentation-5.0/src-asm/com/surelogic/_flashlight/rewriter/FlashlightClassRewriter.java b/flashlight-instrumentation-5.0/src-asm/com/surelogic/_flashlight/rewriter/FlashlightClassRewriter.java
index 987878d..dc2b53e 100644
--- a/flashlight-instrumentation-5.0/src-asm/com/surelogic/_flashlight/rewriter/FlashlightClassRewriter.java
+++ b/flashlight-instrumentation-5.0/src-asm/com/surelogic/_flashlight/rewriter/FlashlightClassRewriter.java
@@ -201,7 +201,7 @@ final class FlashlightClassRewriter extends ClassAdapter {
     if (isInterface) { // Interface, leave alone
       newInterfaces = interfaces;
       mustImplementIIdObject = false;
-    } else if (superName.equals(FlashlightNames.JAVA_LANG_OBJECT) || !classModel.isInstrumentedClass(superName)) {
+    } else if (hasNoInstrumentedAncestor(superName)) {
       /* Class extends Object or a class that is not being instrumented.  Add the
        * IIdObject interface, and we need to add the methods to implement it.
        */
@@ -346,6 +346,26 @@ final class FlashlightClassRewriter extends ClassAdapter {
     cv.visitEnd();
   }
   
+  private boolean hasNoInstrumentedAncestor(final String superName) {
+    String currentName = superName;
+    while (true) {
+      // If we hit java.lang.Object, we are done: there are no instrumented ancestors
+      if (currentName.equals(FlashlightNames.JAVA_LANG_OBJECT)) {
+        return true;
+      }
+      // If the ancestor is instrumented, we are done
+      if (classModel.isInstrumentedClass(currentName)) {
+        return false;
+      }
+      try {
+        currentName = classModel.getClass(currentName).getSuperClass();
+      } catch (final ClassNotFoundException e) {
+        // If we don't know about the class, it is not being instrumented.
+        return false;
+      }
+    } 
+  }
+  
   private void addPhantomClassObjectGetter() {
     // Mark as synthetic because it does not appear in the original source code
     final MethodVisitor mv =
-- 
1.7.4.4

